# -*- coding: utf-8 -*-
"""Week3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15DII2Qhl0pl5yRXmS1ZQGDqi45cY0-ka
"""

import random

alfabet = ['c', 'd']

actions = {
    'Cooperate': 'c',
    'Defect': 'd',
    'Cooperate1':'c',
    'Cooperate2':'c',

}

class DFAPrisoner:
    def __init__(self, states, alfabet, transition_function, start_state, actions):
        self.states = states
        self.alphabet = alfabet
        self.transition_function = transition_function
        self.current_state = start_state
        self.actions = actions

def calculate_scores(player1_moves, player2_moves):
  player1_score=0
  player2_score=0

  for i in range(len(player1_moves)):
      if (player1_moves[i]=='c' and player2_moves[i]=='c'):
        player1_score+=1
        player2_score+=1
      elif (player1_moves[i]=='c' and player2_moves[i]=='d'):
        player1_score+=0
        player2_score+=5
      elif (player1_moves[i]=='d' and player2_moves[i]=='c'):
        player1_score+=5
        player2_score+=0
      elif (player1_moves[i]=='d' and player2_moves[i]=='d'):
        player1_score+=3
        player2_score+=3

  return player1_score, player2_score

class Player:
    def __init__(self, strategy_name):
        self.strategy_name = strategy_name
        self.dfa = self.initialize_dfa(strategy_name)
        self.states, self.alphabet, self.transition_function, self.start_state, self.actions = self.initialize_dfa(strategy_name)
        self.current_state = self.start_state
        self.fisrt_move = self.get_first_move(strategy_name)
    def get_first_move(self, strategy_name):
      if strategy_name=='all_cooperate' or strategy_name=='tit_for_two_tats' :
        return 'c'
      elif strategy_name=='all_defect':
        return 'd'
      elif strategy_name=='tit_for_tat' or strategy_name=='psycho':
        return random.choice(['c', 'd'])

    def initialize_dfa(self, strategy_name):
        if strategy_name == 'all_cooperate':
            states = ['Cooperate']
            transition_function = {
                ('Cooperate', 'c'): 'Cooperate',
                ('Cooperate', 'd'): 'Cooperate',
            }
            start_state = 'Cooperate'
            actions = {'Cooperate': 'c'}

        elif strategy_name == 'all_defect':
            states = ['Defect']
            transition_function = {
                ('Defect', 'c'): 'Defect',
                ('Defect', 'd'): 'Defect',
            }
            start_state = 'Defect'
            actions = {'Defect': 'd'}

        elif strategy_name == 'tit_for_tat':
            states = ['Cooperate', 'Defect']
            transition_function = {
                ('Cooperate', 'c'): 'Cooperate',
                ('Cooperate', 'd'): 'Defect',
                ('Defect', 'c'): 'Cooperate',
                ('Defect', 'd'): 'Defect',
            }
            start_state = 'Cooperate'
            actions = {'Cooperate': 'c', 'Defect': 'd'}

        elif strategy_name == 'tit_for_two_tats':
            states = ['Cooperate1', 'Cooperate2', 'Defect']
            transition_function = {
                ('Cooperate1', 'c'): 'Cooperate1',
                ('Cooperate1', 'd'): 'Cooperate2',
                ('Cooperate2', 'c'): 'Cooperate1',
                ('Cooperate2', 'd'): 'Defect',
                ('Defect', 'c'): 'Cooperate1',
                ('Defect', 'd'): 'Defect',
            }
            start_state = 'Cooperate1'
            actions = {'Cooperate1': 'c', 'Cooperate2': 'c', 'Defect': 'd'}

        elif strategy_name == 'psycho':
            states = ['Cooperate', 'Defect']
            transition_function = {
                ('Cooperate', 'c'): 'Defect',
                ('Cooperate', 'd'): 'Cooperate',
                ('Defect', 'c'): 'Defect',
                ('Defect', 'd'): 'Cooperate',
            }
            start_state = 'Cooperate'
            actions = {'Cooperate': 'c', 'Defect': 'd'}

        else:
            raise ValueError(f"Unknown strategy: {strategy_name}")
        return states, {'c', 'd'}, transition_function, start_state, actions


    def move(self, opponent_move):

            self.current_state = self.transition_function[(self.current_state, opponent_move)]
            return self.actions[self.current_state]



def play(player1, player2):
      player1_moves = []
      player2_moves = []

      num_rounds = 150 + random.randint(-5, 5)

      move1 = player1.move(player1.fisrt_move)
      move2 = player2.move(player2.fisrt_move)

      player1_moves.append(move1)
      player2_moves.append(move2)


      for i in range(1, num_rounds):
        move1 = player1.move(player2_moves[-1])
        move2 = player2.move(player1_moves[-1])
        player1_moves.append(move1)
        player2_moves.append(move2)



      scores = calculate_scores(player1_moves, player2_moves)
      avg_score = (scores[0] + scores[1]) / 2
      print(player1_moves)
      print(player2_moves )
      return scores, avg_score

def round_robin_tournament(players):
      tournament_results = {}

      for i in range(len(players)):
          for j in range(i + 1, len(players)):
              player1 = players[i]
              player2 = players[j]

              print(f"Match: {player1.strategy_name} vs {player2.strategy_name}")


              scores, avg_score = play(player1, player2)

              print(f"Scores: {player1.strategy_name} = {scores[0]}, {player2.strategy_name} = {scores[1]}")
              print(f"Average score: {avg_score}\n")


              tournament_results[(player1.strategy_name, player2.strategy_name)] = scores

      return tournament_results

"""**TOURNAMNET**"""

players = [
    Player('all_cooperate'),
    Player('all_defect'),
    Player( 'tit_for_tat'),
    Player('tit_for_two_tats'),
    Player('psycho')
]

results = round_robin_tournament(players)

